#include <config.h>
#include <asm/arch/romboot.h>
#ifdef USE_HOSTCC
#include <stdio.h>
#include <stdlib.h>
#endif
#include <tfm.h>
#include <sha256-e.h>
#include <aes_keyschedule.h>
#include <aes256_dec.h>
#include <decrypt.h>
#include <asm/arch/romboot.h>

// SPL crypto use ROMBOOT function call
typedef short (*psha256)(const sha256_hash_t * verify,  uint8_t* msg,uint32_t len);
typedef void (*paes256_init)(const void* key, aes256_ctx_t* ctx);
typedef void (*paes256_dec)(void* buffer, aes256_ctx_t* ctx);
typedef int (*pfp_exptmod)(fp_int *a, fp_int *b, fp_int *c, fp_int *d);

static psha256 func_sha256;
static paes256_init func_aes256_init;
static paes256_dec func_aes256_dec;
static pfp_exptmod func_fp_exptmod;

//#define DECRYPT_DEBUG


static int set_romboot_entry(void)
{
	unsigned *rombootversion = 0xd9040004;
	unsigned version;
	version = *rombootversion;
	if(version<2000 || version>5000){
		rombootversion = 0xd904002c;
		version = *rombootversion;
	}
	
	if(version == 0xBBB){
			func_sha256 = 0xd9043c58;
			func_aes256_init = 0xd904412c;
			func_aes256_dec = 0xd9043c8c;
			func_fp_exptmod = 0xd90442f4;
			return 0;
	}
	else
		return -1;	
}

static short read_rsa_pub_key(fp_int *n, fp_int *e)
{
#ifdef 	DECRYPT_DEBUG
	static unsigned char szTxtN[] = {0x27, 0xF9, 0x55, 0x42, 0x36, 0x3B, 0xDC, 0xB5, 0x9C, 0x8C, 0x55, 0xB7, 0xB6, 0x35, 0xD8, 0x60, 0x6D, 0xF0, 0x08, 0xB1, 0xF0, 0xD3, 0xB1, 0x96, 0x88, 0xFF, 0x25, 0xDC, 0x77, 0x8A, 0x1C, 0x42, 0x81, 0x91, 0x7D, 0xFE, 0x31, 0x73, 0x8E, 0xB4, 0x1B, 0x2B, 0x35, 0x88, 0xBE, 0x40, 0x6A, 0xCB, 0x6B, 0x4C, 0xFC, 0x1F, 0xEB, 0x1A, 0xDB, 0x8B, 0x48, 0xAD, 0x13, 0x22, 0xDB, 0x62, 0xF3, 0x75, 0x67, 0xD8, 0x46, 0x0B, 0x93, 0x59, 0xDC, 0x5A, 0x58, 0x4A, 0x18, 0x72, 0x7A, 0x45, 0xAB, 0xB0, 0x2E, 0x13, 0xDD, 0x70, 0x3B, 0x47, 0xB6, 0xE5, 0x6C, 0xE6, 0x7F, 0xEE, 0x9C, 0x34, 0x20, 0x42, 0x88, 0x0D, 0xB8, 0x58, 0xDC, 0xC0, 0x09, 0x9D, 0x27, 0x9A, 0x9D, 0xB2, 0x00, 0xDE, 0x6F, 0x97, 0x6B, 0xF0, 0xE0, 0x02, 0x72, 0x78, 0xD9, 0xCD, 0x4A, 0x03, 0xF6, 0x4E, 0x20, 0xB3, 0x08, 0xD3};
	static unsigned char szTxtE[] = {0x01, 0x00, 0x01};	
	static unsigned char szTxtD[] = {0xC1, 0x84, 0x24, 0x27, 0x1C, 0x27, 0x55, 0xCD, 0x49, 0x9C, 0xFF, 0xCB, 0x3D, 0xC3, 0xE1, 0xF8, 0x63, 0xCE, 0xB8, 0x45, 0x61, 0x18, 0x31, 0xD7, 0xF6, 0xE9, 0x99, 0xDD, 0x36, 0x94, 0xDA, 0xDC, 0xDD, 0x80, 0x61, 0xAD, 0x4E, 0xFA, 0xA3, 0x0B, 0x52, 0xB9, 0x92, 0xE2, 0x23, 0x94, 0x1F, 0x40, 0x56, 0xA4, 0xBE, 0x9C, 0xD2, 0xFC, 0xFD, 0x34, 0x93, 0xC4, 0xD4, 0x2B, 0xEB, 0x4B, 0xD5, 0x18, 0x55, 0x97, 0x6A, 0x89, 0x95, 0x52, 0xC3, 0xEA, 0x5A, 0x34, 0x37, 0x62, 0xD5, 0x5C, 0xA6, 0xFD, 0x03, 0x72, 0xD1, 0xB1, 0x66, 0xCF, 0x50, 0xBE, 0x3B, 0x9D, 0xDE, 0x58, 0x10, 0xE3, 0x2D, 0xB8, 0x73, 0x75, 0x02, 0x1F, 0xDB, 0xAB, 0xBB, 0x9A, 0x16, 0x24, 0x7A, 0xBE, 0x12, 0xCC, 0x79, 0x48, 0xE5, 0x78, 0xD2, 0x61, 0xB6, 0x64, 0xAC, 0x40, 0x97, 0x32, 0x21, 0x21, 0xF2, 0x55, 0xCC, 0x76};
		
	memcpy(n->dp,szTxtN,sizeof(szTxtN));
	memcpy(e->dp,szTxtE,sizeof(szTxtE));
#else
	efuse_read((unsigned *)&(n->dp[0]),EFUSE_SECUREBOOT_RSAKEY,128);///1024 bits from efuse
	e->dp[0]=0x10001;
#endif	
	e->used=FP_SIZE;
	n->used=FP_SIZE;
	fp_clamp(e);
	fp_clamp(n);
	return 0;
}


static short rom_aes_dec(uint8_t * buffer,BL2StorageKey * key)
{
	int i;
	aes256_ctx_t ctx;	
	//if(sha256((const sha256_hash_t* )&key->shasum,(uint8_t*)key,sizeof(*key)-sizeof(key->shasum)))	
	if(func_sha256((const sha256_hash_t* )&key->shasum,(uint8_t*)key,sizeof(*key)-sizeof(key->shasum)))
		return ERROR_RAW_HASH;	
		
	//aes256_init((void*)key->aeskey, &ctx);	
	func_aes256_init((void*)key->aeskey, &ctx);	
	for(i=0;i<sizeof(key->aesmask)/sizeof(key->aesmask[0]);i++)
	{
		if(key->aesmask[i]<0x200||(key->aesmask[i]&0xf)) //found a first page encryption . error
			return ERROR_AES_FORMAT;
		//aes256_dec(&buffer[key->aesmask[i]], &ctx);
		func_aes256_dec(&buffer[key->aesmask[i]], &ctx);
	}		
	return 0;
}

static uint32_t rsa_dec(uint8_t * dest,uint8_t * src,uint32_t len,fp_int * n,fp_int *e)
{
	static fp_int c,m;
	uint32_t i,j;
	uint32_t i_len,o_len;
	i_len=(n->used)<<2;
	o_len=(n->used-1)<<2;

	for(i=0,j=0;i<len;i+=i_len,j+=o_len){
		memset(&c,0,sizeof(c));
		memcpy(&c,&src[i],i_len);
		c.used=FP_SIZE;
		fp_clamp(&c);
		//fp_exptmod(&c,e,n,&m);
		func_fp_exptmod(&c,e,n,&m);
		memcpy(&dest[j],m.dp,o_len);
	}
	return j;
}



short spldecrypt(char *src)
{
	static sha256_hash_t hash;
	static BL2StorageKey storagekey;	
	static fp_int n, e;
	short ret;
	
	// init romboot function entrypoint
	if(set_romboot_entry())
		return ERROR_ROMBOOT_ENTRY;	
	
	/**
     * Read RSAKEY.PUBLIC from Efuse memory
     */     
     //asm volatile("wfi");
	if(read_rsa_pub_key(&n,&e))
		return ERROR_READ_KEY;

	EncryptStorage* enc_stor=(EncryptStorage*)&src[RSA_ENCRYPT_POS];			
	rsa_dec((uint8_t*)&storagekey,(uint8_t*)enc_stor,128*3,&n,&e);		
	bzero(&src[RSA_ENCRYPT_POS],sizeof(*enc_stor));

	ret=rom_aes_dec((uint8_t*)src,&storagekey);
	return 0;	
}